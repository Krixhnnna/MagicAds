{"ast":null,"code":"import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\nconst tmpVec3A = new Vec3();\nconst tmpVec3B = new Vec3();\nconst tmpVec3C = new Vec3();\nconst tmpVec3D = new Vec3();\nconst tmpQuatA = new Quat();\nconst tmpQuatB = new Quat();\nconst tmpQuatC = new Quat();\nconst tmpQuatD = new Quat();\nexport class GLTFAnimation {\n  constructor(data, weight = 1) {\n    this.data = data;\n    this.elapsed = 0;\n    this.weight = weight;\n\n    // Set to false to not apply modulo to elapsed against duration\n    this.loop = true;\n\n    // Get duration from largest final time in all channels\n    this.duration = data.reduce((a, {\n      times\n    }) => Math.max(a, times[times.length - 1]), 0);\n  }\n  update(totalWeight = 1, isSet) {\n    const weight = isSet ? 1 : this.weight / totalWeight;\n    const elapsed = this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration);\n    this.data.forEach(({\n      node,\n      transform,\n      interpolation,\n      times,\n      values\n    }) => {\n      // Get index of two time values elapsed is between\n      const prevIndex = Math.max(1, times.findIndex(t => t > elapsed)) - 1;\n      const nextIndex = prevIndex + 1;\n\n      // Get linear blend/alpha between the two\n      let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n      if (interpolation === 'STEP') alpha = 0;\n      let prevVal = tmpVec3A;\n      let prevTan = tmpVec3B;\n      let nextTan = tmpVec3C;\n      let nextVal = tmpVec3D;\n      let size = 3;\n      if (transform === 'quaternion') {\n        prevVal = tmpQuatA;\n        prevTan = tmpQuatB;\n        nextTan = tmpQuatC;\n        nextVal = tmpQuatD;\n        size = 4;\n      }\n      if (interpolation === 'CUBICSPLINE') {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n        prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n        nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n        nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n        // interpolate for final value\n        prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n        if (size === 4) prevVal.normalize();\n      } else {\n        // Get the prev and next values from the indices\n        prevVal.fromArray(values, prevIndex * size);\n        nextVal.fromArray(values, nextIndex * size);\n\n        // interpolate for final value\n        if (size === 4) prevVal.slerp(nextVal, alpha);else prevVal.lerp(nextVal, alpha);\n      }\n\n      // interpolate between multiple possible animations\n      if (size === 4) node[transform].slerp(prevVal, weight);else node[transform].lerp(prevVal, weight);\n    });\n  }\n  cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n    const t2 = t * t;\n    const t3 = t2 * t;\n    const s2 = 3 * t2 - 2 * t3;\n    const s3 = t3 - t2;\n    const s0 = 1 - s2;\n    const s1 = s3 - t2 + t;\n    for (let i = 0; i < prevVal.length; i++) {\n      prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n    }\n    return prevVal;\n  }\n}","map":{"version":3,"names":["Vec3","Quat","tmpVec3A","tmpVec3B","tmpVec3C","tmpVec3D","tmpQuatA","tmpQuatB","tmpQuatC","tmpQuatD","GLTFAnimation","constructor","data","weight","elapsed","loop","duration","reduce","a","times","Math","max","length","update","totalWeight","isSet","min","forEach","node","transform","interpolation","values","prevIndex","findIndex","t","nextIndex","alpha","prevVal","prevTan","nextTan","nextVal","size","fromArray","cubicSplineInterpolate","normalize","slerp","lerp","t2","t3","s2","s3","s0","s1","i"],"sources":["/Users/krishnapandey/Desktop/Img gen/magicads/node_modules/ogl/src/extras/GLTFAnimation.js"],"sourcesContent":["import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst tmpVec3A = new Vec3();\nconst tmpVec3B = new Vec3();\nconst tmpVec3C = new Vec3();\nconst tmpVec3D = new Vec3();\n\nconst tmpQuatA = new Quat();\nconst tmpQuatB = new Quat();\nconst tmpQuatC = new Quat();\nconst tmpQuatD = new Quat();\n\nexport class GLTFAnimation {\n    constructor(data, weight = 1) {\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = weight;\n\n        // Set to false to not apply modulo to elapsed against duration\n        this.loop = true;\n\n        // Get duration from largest final time in all channels\n        this.duration = data.reduce((a, { times }) => Math.max(a, times[times.length - 1]), 0);\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration);\n\n        this.data.forEach(({ node, transform, interpolation, times, values }) => {\n            // Get index of two time values elapsed is between\n            const prevIndex =\n                Math.max(\n                    1,\n                    times.findIndex((t) => t > elapsed)\n                ) - 1;\n            const nextIndex = prevIndex + 1;\n\n            // Get linear blend/alpha between the two\n            let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n            if (interpolation === 'STEP') alpha = 0;\n\n            let prevVal = tmpVec3A;\n            let prevTan = tmpVec3B;\n            let nextTan = tmpVec3C;\n            let nextVal = tmpVec3D;\n            let size = 3;\n\n            if (transform === 'quaternion') {\n                prevVal = tmpQuatA;\n                prevTan = tmpQuatB;\n                nextTan = tmpQuatC;\n                nextVal = tmpQuatD;\n                size = 4;\n            }\n\n            if (interpolation === 'CUBICSPLINE') {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n                prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n                nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n                nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n                // interpolate for final value\n                prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n                if (size === 4) prevVal.normalize();\n            } else {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size);\n                nextVal.fromArray(values, nextIndex * size);\n\n                // interpolate for final value\n                if (size === 4) prevVal.slerp(nextVal, alpha);\n                else prevVal.lerp(nextVal, alpha);\n            }\n\n            // interpolate between multiple possible animations\n            if (size === 4) node[transform].slerp(prevVal, weight);\n            else node[transform].lerp(prevVal, weight);\n        });\n    }\n\n    cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n\n        const s2 = 3 * t2 - 2 * t3;\n        const s3 = t3 - t2;\n        const s0 = 1 - s2;\n        const s1 = s3 - t2 + t;\n\n        for (let i = 0; i < prevVal.length; i++) {\n            prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n        }\n\n        return prevVal;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}