{"ast":null,"code":"// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\nfunction isPowerOf2(value) {\n  return (value & value - 1) === 0;\n}\nlet ID = 1;\nexport class Texture {\n  constructor(gl, {\n    image,\n    target = gl.TEXTURE_2D,\n    type = gl.UNSIGNED_BYTE,\n    format = gl.RGBA,\n    internalFormat = format,\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    generateMipmaps = true,\n    minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n    magFilter = gl.LINEAR,\n    premultiplyAlpha = false,\n    unpackAlignment = 4,\n    flipY = target == gl.TEXTURE_2D ? true : false,\n    anisotropy = 0,\n    level = 0,\n    width,\n    // used for RenderTargets or Data Textures\n    height = width\n  } = {}) {\n    this.gl = gl;\n    this.id = ID++;\n    this.image = image;\n    this.target = target;\n    this.type = type;\n    this.format = format;\n    this.internalFormat = internalFormat;\n    this.minFilter = minFilter;\n    this.magFilter = magFilter;\n    this.wrapS = wrapS;\n    this.wrapT = wrapT;\n    this.generateMipmaps = generateMipmaps;\n    this.premultiplyAlpha = premultiplyAlpha;\n    this.unpackAlignment = unpackAlignment;\n    this.flipY = flipY;\n    this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n    this.level = level;\n    this.width = width;\n    this.height = height;\n    this.texture = this.gl.createTexture();\n    this.store = {\n      image: null\n    };\n\n    // Alias for state store to avoid redundant calls for global state\n    this.glState = this.gl.renderer.state;\n\n    // State store to avoid redundant calls for per-texture state\n    this.state = {};\n    this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n    this.state.magFilter = this.gl.LINEAR;\n    this.state.wrapS = this.gl.REPEAT;\n    this.state.wrapT = this.gl.REPEAT;\n    this.state.anisotropy = 0;\n  }\n  bind() {\n    // Already bound to active texture unit\n    if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n    this.gl.bindTexture(this.target, this.texture);\n    this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n  }\n  update(textureUnit = 0) {\n    const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n    // Make sure that texture is bound to its texture unit\n    if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n      // set active texture unit to perform texture functions\n      this.gl.renderer.activeTexture(textureUnit);\n      this.bind();\n    }\n    if (!needsUpdate) return;\n    this.needsUpdate = false;\n    if (this.flipY !== this.glState.flipY) {\n      this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n      this.glState.flipY = this.flipY;\n    }\n    if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n      this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n      this.glState.premultiplyAlpha = this.premultiplyAlpha;\n    }\n    if (this.unpackAlignment !== this.glState.unpackAlignment) {\n      this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n      this.glState.unpackAlignment = this.unpackAlignment;\n    }\n    if (this.minFilter !== this.state.minFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n      this.state.minFilter = this.minFilter;\n    }\n    if (this.magFilter !== this.state.magFilter) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n      this.state.magFilter = this.magFilter;\n    }\n    if (this.wrapS !== this.state.wrapS) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n      this.state.wrapS = this.wrapS;\n    }\n    if (this.wrapT !== this.state.wrapT) {\n      this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n      this.state.wrapT = this.wrapT;\n    }\n    if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n      this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n      this.state.anisotropy = this.anisotropy;\n    }\n    if (this.image) {\n      if (this.image.width) {\n        this.width = this.image.width;\n        this.height = this.image.height;\n      }\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // For cube maps\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n        }\n      } else if (ArrayBuffer.isView(this.image)) {\n        // Data texture\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n      } else if (this.image.isCompressedTexture) {\n        // Compressed texture\n        for (let level = 0; level < this.image.length; level++) {\n          this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n        }\n      } else {\n        // Regular texture\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n      }\n      if (this.generateMipmaps) {\n        // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n        if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n          this.generateMipmaps = false;\n          this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n          this.minFilter = this.gl.LINEAR;\n        } else {\n          this.gl.generateMipmap(this.target);\n        }\n      }\n\n      // Callback for when data is pushed to GPU\n      this.onUpdate && this.onUpdate();\n    } else {\n      if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n        // Upload empty pixel for each side while no image to avoid errors while image or video loading\n        for (let i = 0; i < 6; i++) {\n          this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n        }\n      } else if (this.width) {\n        // image intentionally left null for RenderTarget\n        this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n      } else {\n        // Upload empty pixel if no image to avoid errors while image or video loading\n        this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n      }\n    }\n    this.store.image = this.image;\n  }\n}","map":{"version":3,"names":["emptyPixel","Uint8Array","isPowerOf2","value","ID","Texture","constructor","gl","image","target","TEXTURE_2D","type","UNSIGNED_BYTE","format","RGBA","internalFormat","wrapS","CLAMP_TO_EDGE","wrapT","generateMipmaps","minFilter","NEAREST_MIPMAP_LINEAR","LINEAR","magFilter","premultiplyAlpha","unpackAlignment","flipY","anisotropy","level","width","height","id","Math","min","renderer","parameters","maxAnisotropy","texture","createTexture","store","glState","state","REPEAT","bind","textureUnits","activeTextureUnit","bindTexture","update","textureUnit","needsUpdate","activeTexture","pixelStorei","UNPACK_FLIP_Y_WEBGL","UNPACK_PREMULTIPLY_ALPHA_WEBGL","UNPACK_ALIGNMENT","texParameteri","TEXTURE_MIN_FILTER","TEXTURE_MAG_FILTER","TEXTURE_WRAP_S","TEXTURE_WRAP_T","texParameterf","getExtension","TEXTURE_MAX_ANISOTROPY_EXT","TEXTURE_CUBE_MAP","i","texImage2D","TEXTURE_CUBE_MAP_POSITIVE_X","ArrayBuffer","isView","isCompressedTexture","length","compressedTexImage2D","data","isWebgl2","generateMipmap","onUpdate"],"sources":["/Users/krishnapandey/Desktop/Img gen/magicads/node_modules/ogl/src/core/Texture.js"],"sourcesContent":["// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n}\n\nlet ID = 1;\n\nexport class Texture {\n    constructor(\n        gl,\n        {\n            image,\n            target = gl.TEXTURE_2D,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            generateMipmaps = true,\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = target == gl.TEXTURE_2D ? true : false,\n            anisotropy = 0,\n            level = 0,\n            width, // used for RenderTargets or Data Textures\n            height = width,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.id = ID++;\n\n        this.image = image;\n        this.target = target;\n        this.type = type;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.minFilter = minFilter;\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.generateMipmaps = generateMipmaps;\n        this.premultiplyAlpha = premultiplyAlpha;\n        this.unpackAlignment = unpackAlignment;\n        this.flipY = flipY;\n        this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.texture = this.gl.createTexture();\n\n        this.store = {\n            image: null,\n        };\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // State store to avoid redundant calls for per-texture state\n        this.state = {};\n        this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        this.state.magFilter = this.gl.LINEAR;\n        this.state.wrapS = this.gl.REPEAT;\n        this.state.wrapT = this.gl.REPEAT;\n        this.state.anisotropy = 0;\n    }\n\n    bind() {\n        // Already bound to active texture unit\n        if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n        this.gl.bindTexture(this.target, this.texture);\n        this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n    }\n\n    update(textureUnit = 0) {\n        const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n        // Make sure that texture is bound to its texture unit\n        if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n            // set active texture unit to perform texture functions\n            this.gl.renderer.activeTexture(textureUnit);\n            this.bind();\n        }\n\n        if (!needsUpdate) return;\n        this.needsUpdate = false;\n\n        if (this.flipY !== this.glState.flipY) {\n            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n            this.glState.flipY = this.flipY;\n        }\n\n        if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n            this.glState.premultiplyAlpha = this.premultiplyAlpha;\n        }\n\n        if (this.unpackAlignment !== this.glState.unpackAlignment) {\n            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n            this.glState.unpackAlignment = this.unpackAlignment;\n        }\n\n        if (this.minFilter !== this.state.minFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n            this.state.minFilter = this.minFilter;\n        }\n\n        if (this.magFilter !== this.state.magFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n            this.state.magFilter = this.magFilter;\n        }\n\n        if (this.wrapS !== this.state.wrapS) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n            this.state.wrapS = this.wrapS;\n        }\n\n        if (this.wrapT !== this.state.wrapT) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n            this.state.wrapT = this.wrapT;\n        }\n\n        if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n            this.gl.texParameterf(\n                this.target,\n                this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT,\n                this.anisotropy\n            );\n            this.state.anisotropy = this.anisotropy;\n        }\n\n        if (this.image) {\n            if (this.image.width) {\n                this.width = this.image.width;\n                this.height = this.image.height;\n            }\n\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // For cube maps\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(\n                        this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\n                        this.level,\n                        this.internalFormat,\n                        this.format,\n                        this.type,\n                        this.image[i]\n                    );\n                }\n            } else if (ArrayBuffer.isView(this.image)) {\n                // Data texture\n                this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n            } else if (this.image.isCompressedTexture) {\n                // Compressed texture\n                for (let level = 0; level < this.image.length; level++) {\n                    this.gl.compressedTexImage2D(\n                        this.target,\n                        level,\n                        this.internalFormat,\n                        this.image[level].width,\n                        this.image[level].height,\n                        0,\n                        this.image[level].data\n                    );\n                }\n            } else {\n                // Regular texture\n                this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n            }\n\n            if (this.generateMipmaps) {\n                // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n                if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n                    this.generateMipmaps = false;\n                    this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n                    this.minFilter = this.gl.LINEAR;\n                } else {\n                    this.gl.generateMipmap(this.target);\n                }\n            }\n\n            // Callback for when data is pushed to GPU\n            this.onUpdate && this.onUpdate();\n        } else {\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // Upload empty pixel for each side while no image to avoid errors while image or video loading\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(\n                        this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i,\n                        0,\n                        this.gl.RGBA,\n                        1,\n                        1,\n                        0,\n                        this.gl.RGBA,\n                        this.gl.UNSIGNED_BYTE,\n                        emptyPixel\n                    );\n                }\n            } else if (this.width) {\n                // image intentionally left null for RenderTarget\n                this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n            } else {\n                // Upload empty pixel if no image to avoid errors while image or video loading\n                this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n            }\n        }\n        this.store.image = this.image;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}