{"ast":null,"code":"import { Texture } from '../core/Texture.js';\nimport { KTXTexture } from './KTXTexture.js';\n\n// For compressed textures, generate using https://github.com/TimvanScherpenzeel/texture-compressor\n\nlet cache = {};\nconst supportedExtensions = [];\nexport class TextureLoader {\n  static load(gl, {\n    src,\n    // string or object of extension:src key-values\n    // {\n    //     pvrtc: '...ktx',\n    //     s3tc: '...ktx',\n    //     etc: '...ktx',\n    //     etc1: '...ktx',\n    //     astc: '...ktx',\n    //     webp: '...webp',\n    //     jpg: '...jpg',\n    //     png: '...png',\n    // }\n\n    // Only props relevant to KTXTexture\n    wrapS = gl.CLAMP_TO_EDGE,\n    wrapT = gl.CLAMP_TO_EDGE,\n    anisotropy = 0,\n    // For regular images\n    format = gl.RGBA,\n    internalFormat = format,\n    generateMipmaps = true,\n    minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n    magFilter = gl.LINEAR,\n    premultiplyAlpha = false,\n    unpackAlignment = 4,\n    flipY = true\n  } = {}) {\n    const support = this.getSupportedExtensions(gl);\n    let ext = 'none';\n\n    // If src is string, determine which format from the extension\n    if (typeof src === 'string') {\n      ext = src.split('.').pop().split('?')[0].toLowerCase();\n    }\n\n    // If src is object, use supported extensions and provided list to choose best option\n    // Get first supported match, so put in order of preference\n    if (typeof src === 'object') {\n      for (const prop in src) {\n        if (support.includes(prop.toLowerCase())) {\n          ext = prop.toLowerCase();\n          src = src[prop];\n          break;\n        }\n      }\n    }\n\n    // Stringify props\n    const cacheID = src + wrapS + wrapT + anisotropy + format + internalFormat + generateMipmaps + minFilter + magFilter + premultiplyAlpha + unpackAlignment + flipY + gl.renderer.id;\n\n    // Check cache for existing texture\n    if (cache[cacheID]) return cache[cacheID];\n    let texture;\n    switch (ext) {\n      case 'ktx':\n      case 'pvrtc':\n      case 's3tc':\n      case 'etc':\n      case 'etc1':\n      case 'astc':\n        // Load compressed texture using KTX format\n        texture = new KTXTexture(gl, {\n          src,\n          wrapS,\n          wrapT,\n          anisotropy\n        });\n        texture.loaded = this.loadKTX(src, texture);\n        break;\n      case 'webp':\n      case 'jpg':\n      case 'jpeg':\n      case 'png':\n        texture = new Texture(gl, {\n          wrapS,\n          wrapT,\n          anisotropy,\n          format,\n          internalFormat,\n          generateMipmaps,\n          minFilter,\n          magFilter,\n          premultiplyAlpha,\n          unpackAlignment,\n          flipY\n        });\n        texture.loaded = this.loadImage(gl, src, texture);\n        break;\n      default:\n        console.warn('No supported format supplied');\n        texture = new Texture(gl);\n    }\n    texture.ext = ext;\n    cache[cacheID] = texture;\n    return texture;\n  }\n  static getSupportedExtensions(gl) {\n    if (supportedExtensions.length) return supportedExtensions;\n    const extensions = {\n      pvrtc: gl.renderer.getExtension('WEBGL_compressed_texture_pvrtc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n      s3tc: gl.renderer.getExtension('WEBGL_compressed_texture_s3tc') || gl.renderer.getExtension('MOZ_WEBGL_compressed_texture_s3tc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc'),\n      etc: gl.renderer.getExtension('WEBGL_compressed_texture_etc'),\n      etc1: gl.renderer.getExtension('WEBGL_compressed_texture_etc1'),\n      astc: gl.renderer.getExtension('WEBGL_compressed_texture_astc')\n    };\n    for (const ext in extensions) if (extensions[ext]) supportedExtensions.push(ext);\n\n    // Check for WebP support\n    if (detectWebP) supportedExtensions.push('webp');\n\n    // Formats supported by all\n    supportedExtensions.push('png', 'jpg');\n    return supportedExtensions;\n  }\n  static loadKTX(src, texture) {\n    return fetch(src).then(res => res.arrayBuffer()).then(buffer => texture.parseBuffer(buffer));\n  }\n  static loadImage(gl, src, texture) {\n    return decodeImage(src).then(imgBmp => {\n      // Catch non POT textures and update params to avoid errors\n      if (!powerOfTwo(imgBmp.width) || !powerOfTwo(imgBmp.height)) {\n        if (texture.generateMipmaps) texture.generateMipmaps = false;\n        if (texture.minFilter === gl.NEAREST_MIPMAP_LINEAR) texture.minFilter = gl.LINEAR;\n        if (texture.wrapS === gl.REPEAT) texture.wrapS = texture.wrapT = gl.CLAMP_TO_EDGE;\n      }\n      texture.image = imgBmp;\n\n      // For createImageBitmap, close once uploaded\n      texture.onUpdate = () => {\n        if (imgBmp.close) imgBmp.close();\n        texture.onUpdate = null;\n      };\n      return imgBmp;\n    });\n  }\n  static clearCache() {\n    cache = {};\n  }\n}\nfunction detectWebP() {\n  return document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;\n}\nfunction powerOfTwo(value) {\n  return Math.log2(value) % 1 === 0;\n}\nfunction decodeImage(src) {\n  return new Promise(resolve => {\n    const img = new Image();\n    img.src = src;\n\n    // Only chrome's implementation of createImageBitmap is fully supported\n    const isChrome = navigator.userAgent.toLowerCase().includes('chrome');\n    if (!!window.createImageBitmap && isChrome) {\n      img.onload = () => {\n        createImageBitmap(img, {\n          imageOrientation: 'flipY',\n          premultiplyAlpha: 'none'\n        }).then(imgBmp => {\n          resolve(imgBmp);\n        });\n      };\n    } else {\n      img.onload = () => resolve(img);\n    }\n  });\n}","map":{"version":3,"names":["Texture","KTXTexture","cache","supportedExtensions","TextureLoader","load","gl","src","wrapS","CLAMP_TO_EDGE","wrapT","anisotropy","format","RGBA","internalFormat","generateMipmaps","minFilter","NEAREST_MIPMAP_LINEAR","LINEAR","magFilter","premultiplyAlpha","unpackAlignment","flipY","support","getSupportedExtensions","ext","split","pop","toLowerCase","prop","includes","cacheID","renderer","id","texture","loaded","loadKTX","loadImage","console","warn","length","extensions","pvrtc","getExtension","s3tc","etc","etc1","astc","push","detectWebP","fetch","then","res","arrayBuffer","buffer","parseBuffer","decodeImage","imgBmp","powerOfTwo","width","height","REPEAT","image","onUpdate","close","clearCache","document","createElement","toDataURL","indexOf","value","Math","log2","Promise","resolve","img","Image","isChrome","navigator","userAgent","window","createImageBitmap","onload","imageOrientation"],"sources":["/Users/krishnapandey/Desktop/Img gen/magicads/node_modules/ogl/src/extras/TextureLoader.js"],"sourcesContent":["import { Texture } from '../core/Texture.js';\nimport { KTXTexture } from './KTXTexture.js';\n\n// For compressed textures, generate using https://github.com/TimvanScherpenzeel/texture-compressor\n\nlet cache = {};\nconst supportedExtensions = [];\n\nexport class TextureLoader {\n    static load(\n        gl,\n        {\n            src, // string or object of extension:src key-values\n            // {\n            //     pvrtc: '...ktx',\n            //     s3tc: '...ktx',\n            //     etc: '...ktx',\n            //     etc1: '...ktx',\n            //     astc: '...ktx',\n            //     webp: '...webp',\n            //     jpg: '...jpg',\n            //     png: '...png',\n            // }\n\n            // Only props relevant to KTXTexture\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            anisotropy = 0,\n\n            // For regular images\n            format = gl.RGBA,\n            internalFormat = format,\n            generateMipmaps = true,\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = true,\n        } = {}\n    ) {\n        const support = this.getSupportedExtensions(gl);\n        let ext = 'none';\n\n        // If src is string, determine which format from the extension\n        if (typeof src === 'string') {\n            ext = src.split('.').pop().split('?')[0].toLowerCase();\n        }\n\n        // If src is object, use supported extensions and provided list to choose best option\n        // Get first supported match, so put in order of preference\n        if (typeof src === 'object') {\n            for (const prop in src) {\n                if (support.includes(prop.toLowerCase())) {\n                    ext = prop.toLowerCase();\n                    src = src[prop];\n                    break;\n                }\n            }\n        }\n\n        // Stringify props\n        const cacheID =\n            src +\n            wrapS +\n            wrapT +\n            anisotropy +\n            format +\n            internalFormat +\n            generateMipmaps +\n            minFilter +\n            magFilter +\n            premultiplyAlpha +\n            unpackAlignment +\n            flipY +\n            gl.renderer.id;\n\n        // Check cache for existing texture\n        if (cache[cacheID]) return cache[cacheID];\n\n        let texture;\n        switch (ext) {\n            case 'ktx':\n            case 'pvrtc':\n            case 's3tc':\n            case 'etc':\n            case 'etc1':\n            case 'astc':\n                // Load compressed texture using KTX format\n                texture = new KTXTexture(gl, {\n                    src,\n                    wrapS,\n                    wrapT,\n                    anisotropy,\n                });\n                texture.loaded = this.loadKTX(src, texture);\n                break;\n            case 'webp':\n            case 'jpg':\n            case 'jpeg':\n            case 'png':\n                texture = new Texture(gl, {\n                    wrapS,\n                    wrapT,\n                    anisotropy,\n                    format,\n                    internalFormat,\n                    generateMipmaps,\n                    minFilter,\n                    magFilter,\n                    premultiplyAlpha,\n                    unpackAlignment,\n                    flipY,\n                });\n                texture.loaded = this.loadImage(gl, src, texture);\n                break;\n            default:\n                console.warn('No supported format supplied');\n                texture = new Texture(gl);\n        }\n\n        texture.ext = ext;\n        cache[cacheID] = texture;\n        return texture;\n    }\n\n    static getSupportedExtensions(gl) {\n        if (supportedExtensions.length) return supportedExtensions;\n\n        const extensions = {\n            pvrtc: gl.renderer.getExtension('WEBGL_compressed_texture_pvrtc') || gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc'),\n            s3tc:\n                gl.renderer.getExtension('WEBGL_compressed_texture_s3tc') ||\n                gl.renderer.getExtension('MOZ_WEBGL_compressed_texture_s3tc') ||\n                gl.renderer.getExtension('WEBKIT_WEBGL_compressed_texture_s3tc'),\n            etc: gl.renderer.getExtension('WEBGL_compressed_texture_etc'),\n            etc1: gl.renderer.getExtension('WEBGL_compressed_texture_etc1'),\n            astc: gl.renderer.getExtension('WEBGL_compressed_texture_astc'),\n        };\n\n        for (const ext in extensions) if (extensions[ext]) supportedExtensions.push(ext);\n\n        // Check for WebP support\n        if (detectWebP) supportedExtensions.push('webp');\n\n        // Formats supported by all\n        supportedExtensions.push('png', 'jpg');\n\n        return supportedExtensions;\n    }\n\n    static loadKTX(src, texture) {\n        return fetch(src)\n            .then((res) => res.arrayBuffer())\n            .then((buffer) => texture.parseBuffer(buffer));\n    }\n\n    static loadImage(gl, src, texture) {\n        return decodeImage(src).then((imgBmp) => {\n            // Catch non POT textures and update params to avoid errors\n            if (!powerOfTwo(imgBmp.width) || !powerOfTwo(imgBmp.height)) {\n                if (texture.generateMipmaps) texture.generateMipmaps = false;\n                if (texture.minFilter === gl.NEAREST_MIPMAP_LINEAR) texture.minFilter = gl.LINEAR;\n                if (texture.wrapS === gl.REPEAT) texture.wrapS = texture.wrapT = gl.CLAMP_TO_EDGE;\n            }\n\n            texture.image = imgBmp;\n\n            // For createImageBitmap, close once uploaded\n            texture.onUpdate = () => {\n                if (imgBmp.close) imgBmp.close();\n                texture.onUpdate = null;\n            };\n\n            return imgBmp;\n        });\n    }\n\n    static clearCache() {\n        cache = {};\n    }\n}\n\nfunction detectWebP() {\n    return document.createElement('canvas').toDataURL('image/webp').indexOf('data:image/webp') == 0;\n}\n\nfunction powerOfTwo(value) {\n    return Math.log2(value) % 1 === 0;\n}\n\nfunction decodeImage(src) {\n    return new Promise((resolve) => {\n        const img = new Image();\n        img.src = src;\n\n        // Only chrome's implementation of createImageBitmap is fully supported\n        const isChrome = navigator.userAgent.toLowerCase().includes('chrome');\n        if (!!window.createImageBitmap && isChrome) {\n            img.onload = () => {\n                createImageBitmap(img, {\n                    imageOrientation: 'flipY',\n                    premultiplyAlpha: 'none',\n                }).then((imgBmp) => {\n                    resolve(imgBmp);\n                });\n            };\n        } else {\n            img.onload = () => resolve(img);\n        }\n    });\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}