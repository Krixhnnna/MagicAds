{"ast":null,"code":"// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n// TODO: when would I disableVertexAttribArray ?\n// TODO: use offset/stride if exists\n\nimport { Vec3 } from '../math/Vec3.js';\nconst tempVec3 = new Vec3();\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\nexport class Geometry {\n  constructor(gl, attributes = {}) {\n    if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n    this.gl = gl;\n    this.attributes = attributes;\n    this.id = ID++;\n\n    // Store one VAO per program attribute locations order\n    this.VAOs = {};\n    this.drawRange = {\n      start: 0,\n      count: 0\n    };\n    this.instancedCount = 0;\n\n    // Unbind current VAO so that new buffers don't get added to active mesh\n    this.gl.renderer.bindVertexArray(null);\n    this.gl.renderer.currentGeometry = null;\n\n    // Alias for state store to avoid redundant calls for global state\n    this.glState = this.gl.renderer.state;\n\n    // create the buffers\n    for (let key in attributes) {\n      this.addAttribute(key, attributes[key]);\n    }\n  }\n  addAttribute(key, attr) {\n    this.attributes[key] = attr;\n\n    // Set options\n    attr.id = ATTR_ID++; // TODO: currently unused, remove?\n    attr.size = attr.size || 1;\n    attr.type = attr.type || (attr.data.constructor === Float32Array ? this.gl.FLOAT : attr.data.constructor === Uint16Array ? this.gl.UNSIGNED_SHORT : this.gl.UNSIGNED_INT); // Uint32Array\n    attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n    attr.normalized = attr.normalized || false;\n    attr.stride = attr.stride || 0;\n    attr.offset = attr.offset || 0;\n    attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n    attr.divisor = attr.instanced || 0;\n    attr.needsUpdate = false;\n    if (!attr.buffer) {\n      attr.buffer = this.gl.createBuffer();\n\n      // Push data to buffer\n      this.updateAttribute(attr);\n    }\n\n    // Update geometry counts. If indexed, ignore regular attributes\n    if (attr.divisor) {\n      this.isInstanced = true;\n      if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n        console.warn('geometry has multiple instanced buffers of different length');\n        return this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor);\n      }\n      this.instancedCount = attr.count * attr.divisor;\n    } else if (key === 'index') {\n      this.drawRange.count = attr.count;\n    } else if (!this.attributes.index) {\n      this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n    }\n  }\n  updateAttribute(attr) {\n    if (this.glState.boundBuffer !== attr.buffer) {\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n    }\n    this.gl.bufferData(attr.target, attr.data, this.gl.STATIC_DRAW);\n    attr.needsUpdate = false;\n  }\n  setIndex(value) {\n    this.addAttribute('index', value);\n  }\n  setDrawRange(start, count) {\n    this.drawRange.start = start;\n    this.drawRange.count = count;\n  }\n  setInstancedCount(value) {\n    this.instancedCount = value;\n  }\n  createVAO(program) {\n    this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n    this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n    this.bindAttributes(program);\n  }\n  bindAttributes(program) {\n    // Link all attributes to program using gl.vertexAttribPointer\n    program.attributeLocations.forEach((location, {\n      name,\n      type\n    }) => {\n      // If geometry missing a required shader attribute\n      if (!this.attributes[name]) {\n        console.warn(`active attribute ${name} not being supplied`);\n        return;\n      }\n      const attr = this.attributes[name];\n      this.gl.bindBuffer(attr.target, attr.buffer);\n      this.glState.boundBuffer = attr.buffer;\n\n      // For matrix attributes, buffer needs to be defined per column\n      let numLoc = 1;\n      if (type === 35674) numLoc = 2; // mat2\n      if (type === 35675) numLoc = 3; // mat3\n      if (type === 35676) numLoc = 4; // mat4\n\n      const size = attr.size / numLoc;\n      const stride = numLoc === 1 ? 0 : numLoc * numLoc * numLoc;\n      const offset = numLoc === 1 ? 0 : numLoc * numLoc;\n      for (let i = 0; i < numLoc; i++) {\n        this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n        this.gl.enableVertexAttribArray(location + i);\n\n        // For instanced attributes, divisor needs to be set.\n        // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n        this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n      }\n    });\n\n    // Bind indices if geometry indexed\n    if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n  }\n  draw({\n    program,\n    mode = this.gl.TRIANGLES\n  }) {\n    if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n      if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n      this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n      this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n    }\n\n    // Check if any attributes need updating\n    program.attributeLocations.forEach((location, {\n      name\n    }) => {\n      const attr = this.attributes[name];\n      if (attr.needsUpdate) this.updateAttribute(attr);\n    });\n    if (this.isInstanced) {\n      if (this.attributes.index) {\n        this.gl.renderer.drawElementsInstanced(mode, this.drawRange.count, this.attributes.index.type, this.drawRange.start, this.instancedCount);\n      } else {\n        this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n      }\n    } else {\n      if (this.attributes.index) {\n        this.gl.drawElements(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * 2);\n      } else {\n        this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n      }\n    }\n  }\n  getPositionArray() {\n    // Use position buffer, or min/max if available\n    const attr = this.attributes.position;\n    if (attr.min) return [...attr.min, ...attr.max];\n    if (attr.data) return attr.data;\n    if (isBoundsWarned) return;\n    console.warn('No position buffer data found to compute bounds');\n    return isBoundsWarned = true;\n  }\n  computeBoundingBox(array) {\n    if (!array) array = this.getPositionArray();\n    if (!this.bounds) {\n      this.bounds = {\n        min: new Vec3(),\n        max: new Vec3(),\n        center: new Vec3(),\n        scale: new Vec3(),\n        radius: Infinity\n      };\n    }\n    const min = this.bounds.min;\n    const max = this.bounds.max;\n    const center = this.bounds.center;\n    const scale = this.bounds.scale;\n    min.set(+Infinity);\n    max.set(-Infinity);\n\n    // TODO: use offset/stride if exists\n    // TODO: check size of position (eg triangle with Vec2)\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      const x = array[i];\n      const y = array[i + 1];\n      const z = array[i + 2];\n      min.x = Math.min(x, min.x);\n      min.y = Math.min(y, min.y);\n      min.z = Math.min(z, min.z);\n      max.x = Math.max(x, max.x);\n      max.y = Math.max(y, max.y);\n      max.z = Math.max(z, max.z);\n    }\n    scale.sub(max, min);\n    center.add(min, max).divide(2);\n  }\n  computeBoundingSphere(array) {\n    if (!array) array = this.getPositionArray();\n    if (!this.bounds) this.computeBoundingBox(array);\n    let maxRadiusSq = 0;\n    for (let i = 0, l = array.length; i < l; i += 3) {\n      tempVec3.fromArray(array, i);\n      maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n    }\n    this.bounds.radius = Math.sqrt(maxRadiusSq);\n  }\n  remove() {\n    if (this.vao) this.gl.renderer.deleteVertexArray(this.vao);\n    for (let key in this.attributes) {\n      this.gl.deleteBuffer(this.attributes[key].buffer);\n      delete this.attributes[key];\n    }\n  }\n}","map":{"version":3,"names":["Vec3","tempVec3","ID","ATTR_ID","isBoundsWarned","Geometry","constructor","gl","attributes","canvas","console","error","id","VAOs","drawRange","start","count","instancedCount","renderer","bindVertexArray","currentGeometry","glState","state","key","addAttribute","attr","size","type","data","Float32Array","FLOAT","Uint16Array","UNSIGNED_SHORT","UNSIGNED_INT","target","ELEMENT_ARRAY_BUFFER","ARRAY_BUFFER","normalized","stride","offset","byteLength","length","divisor","instanced","needsUpdate","buffer","createBuffer","updateAttribute","isInstanced","warn","Math","min","index","max","boundBuffer","bindBuffer","bufferData","STATIC_DRAW","setIndex","value","setDrawRange","setInstancedCount","createVAO","program","attributeOrder","createVertexArray","bindAttributes","attributeLocations","forEach","location","name","numLoc","i","vertexAttribPointer","enableVertexAttribArray","vertexAttribDivisor","draw","mode","TRIANGLES","drawElementsInstanced","drawArraysInstanced","drawElements","drawArrays","getPositionArray","position","computeBoundingBox","array","bounds","center","scale","radius","Infinity","set","l","x","y","z","sub","add","divide","computeBoundingSphere","maxRadiusSq","fromArray","squaredDistance","sqrt","remove","vao","deleteVertexArray","deleteBuffer"],"sources":["/Users/krishnapandey/Desktop/Img gen/magicads/node_modules/ogl/src/core/Geometry.js"],"sourcesContent":["// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n// TODO: when would I disableVertexAttribArray ?\n// TODO: use offset/stride if exists\n\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempVec3 = new Vec3();\n\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\n\nexport class Geometry {\n    constructor(gl, attributes = {}) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n        this.gl = gl;\n        this.attributes = attributes;\n        this.id = ID++;\n\n        // Store one VAO per program attribute locations order\n        this.VAOs = {};\n\n        this.drawRange = { start: 0, count: 0 };\n        this.instancedCount = 0;\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        this.gl.renderer.bindVertexArray(null);\n        this.gl.renderer.currentGeometry = null;\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // create the buffers\n        for (let key in attributes) {\n            this.addAttribute(key, attributes[key]);\n        }\n    }\n\n    addAttribute(key, attr) {\n        this.attributes[key] = attr;\n\n        // Set options\n        attr.id = ATTR_ID++; // TODO: currently unused, remove?\n        attr.size = attr.size || 1;\n        attr.type =\n            attr.type ||\n            (attr.data.constructor === Float32Array\n                ? this.gl.FLOAT\n                : attr.data.constructor === Uint16Array\n                ? this.gl.UNSIGNED_SHORT\n                : this.gl.UNSIGNED_INT); // Uint32Array\n        attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n        attr.normalized = attr.normalized || false;\n        attr.stride = attr.stride || 0;\n        attr.offset = attr.offset || 0;\n        attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n        attr.divisor = attr.instanced || 0;\n        attr.needsUpdate = false;\n\n        if (!attr.buffer) {\n            attr.buffer = this.gl.createBuffer();\n\n            // Push data to buffer\n            this.updateAttribute(attr);\n        }\n\n        // Update geometry counts. If indexed, ignore regular attributes\n        if (attr.divisor) {\n            this.isInstanced = true;\n            if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n                console.warn('geometry has multiple instanced buffers of different length');\n                return (this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor));\n            }\n            this.instancedCount = attr.count * attr.divisor;\n        } else if (key === 'index') {\n            this.drawRange.count = attr.count;\n        } else if (!this.attributes.index) {\n            this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n        }\n    }\n\n    updateAttribute(attr) {\n        if (this.glState.boundBuffer !== attr.buffer) {\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n        }\n        this.gl.bufferData(attr.target, attr.data, this.gl.STATIC_DRAW);\n        attr.needsUpdate = false;\n    }\n\n    setIndex(value) {\n        this.addAttribute('index', value);\n    }\n\n    setDrawRange(start, count) {\n        this.drawRange.start = start;\n        this.drawRange.count = count;\n    }\n\n    setInstancedCount(value) {\n        this.instancedCount = value;\n    }\n\n    createVAO(program) {\n        this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n        this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n        this.bindAttributes(program);\n    }\n\n    bindAttributes(program) {\n        // Link all attributes to program using gl.vertexAttribPointer\n        program.attributeLocations.forEach((location, { name, type }) => {\n            // If geometry missing a required shader attribute\n            if (!this.attributes[name]) {\n                console.warn(`active attribute ${name} not being supplied`);\n                return;\n            }\n\n            const attr = this.attributes[name];\n\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n\n            // For matrix attributes, buffer needs to be defined per column\n            let numLoc = 1;\n            if (type === 35674) numLoc = 2; // mat2\n            if (type === 35675) numLoc = 3; // mat3\n            if (type === 35676) numLoc = 4; // mat4\n\n            const size = attr.size / numLoc;\n            const stride = numLoc === 1 ? 0 : numLoc * numLoc * numLoc;\n            const offset = numLoc === 1 ? 0 : numLoc * numLoc;\n\n            for (let i = 0; i < numLoc; i++) {\n                this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n                this.gl.enableVertexAttribArray(location + i);\n\n                // For instanced attributes, divisor needs to be set.\n                // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n                this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n            }\n        });\n\n        // Bind indices if geometry indexed\n        if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n    }\n\n    draw({ program, mode = this.gl.TRIANGLES }) {\n        if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n            if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n            this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n            this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n        }\n\n        // Check if any attributes need updating\n        program.attributeLocations.forEach((location, { name }) => {\n            const attr = this.attributes[name];\n            if (attr.needsUpdate) this.updateAttribute(attr);\n        });\n\n        if (this.isInstanced) {\n            if (this.attributes.index) {\n                this.gl.renderer.drawElementsInstanced(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.drawRange.start,\n                    this.instancedCount\n                );\n            } else {\n                this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n            }\n        } else {\n            if (this.attributes.index) {\n                this.gl.drawElements(mode, this.drawRange.count, this.attributes.index.type, this.attributes.index.offset + this.drawRange.start * 2);\n            } else {\n                this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n            }\n        }\n    }\n\n    getPositionArray() {\n        // Use position buffer, or min/max if available\n        const attr = this.attributes.position;\n        if (attr.min) return [...attr.min, ...attr.max];\n        if (attr.data) return attr.data;\n        if (isBoundsWarned) return;\n        console.warn('No position buffer data found to compute bounds');\n        return (isBoundsWarned = true);\n    }\n\n    computeBoundingBox(array) {\n        if (!array) array = this.getPositionArray();\n\n        if (!this.bounds) {\n            this.bounds = {\n                min: new Vec3(),\n                max: new Vec3(),\n                center: new Vec3(),\n                scale: new Vec3(),\n                radius: Infinity,\n            };\n        }\n\n        const min = this.bounds.min;\n        const max = this.bounds.max;\n        const center = this.bounds.center;\n        const scale = this.bounds.scale;\n\n        min.set(+Infinity);\n        max.set(-Infinity);\n\n        // TODO: use offset/stride if exists\n        // TODO: check size of position (eg triangle with Vec2)\n        for (let i = 0, l = array.length; i < l; i += 3) {\n            const x = array[i];\n            const y = array[i + 1];\n            const z = array[i + 2];\n\n            min.x = Math.min(x, min.x);\n            min.y = Math.min(y, min.y);\n            min.z = Math.min(z, min.z);\n\n            max.x = Math.max(x, max.x);\n            max.y = Math.max(y, max.y);\n            max.z = Math.max(z, max.z);\n        }\n\n        scale.sub(max, min);\n        center.add(min, max).divide(2);\n    }\n\n    computeBoundingSphere(array) {\n        if (!array) array = this.getPositionArray();\n        if (!this.bounds) this.computeBoundingBox(array);\n\n        let maxRadiusSq = 0;\n        for (let i = 0, l = array.length; i < l; i += 3) {\n            tempVec3.fromArray(array, i);\n            maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n        }\n\n        this.bounds.radius = Math.sqrt(maxRadiusSq);\n    }\n\n    remove() {\n        if (this.vao) this.gl.renderer.deleteVertexArray(this.vao);\n        for (let key in this.attributes) {\n            this.gl.deleteBuffer(this.attributes[key].buffer);\n            delete this.attributes[key];\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}